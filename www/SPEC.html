
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SPEC.md</title>

	<link rel="stylesheet" href="./style.css">
</head>
<body>
	<h1 id="cyraon-language-specification" tabindex="-1">Cyraon Language Specification</h1>
<h2 id="syntax" tabindex="-1">Syntax</h2>
<p>Cyraon Syntax is consisted of two concepts: <strong>Node</strong> and <strong>Expr</strong></p>
<p><strong>Node</strong>
: Forms the general structure of the code.</p>
<p><strong>Expr</strong>
: Fill in the details of a <strong>node</strong>. Technically, a <strong>node</strong> can contain</p>
<h3 id="operator-precedence-(high-to-low)" tabindex="-1">Operator Precedence (High to Low)</h3>
<ul>
<li>12:
<ul>
<li>ParenExpr <code>(</code>...<code>)</code></li>
</ul>
</li>
<li>11
<ul>
<li>Literal
<ul>
<li>Int Float Tuple List etc.</li>
</ul>
</li>
<li><a href="#block">Block</a></li>
<li>Variable</li>
<li><a href="#lambda">Lambda</a></li>
</ul>
</li>
<li>10 <strong>Left Associative</strong>
<ul>
<li><a href="">FnCall &amp; its variants</a></li>
<li><a href="">Index &amp; its variants</a></li>
</ul>
</li>
<li>9 <strong>Right Associative</strong> Unaries
<ul>
<li><code>!</code>...</li>
<li><code>+</code>...</li>
<li><code>-</code>...</li>
<li><code>~</code>...</li>
</ul>
</li>
<li>8 <strong>Right Associative</strong> Power ...<code>**</code>...</li>
<li>7 <strong>Left Associative</strong> Higher Arithmetics
<ul>
<li>...<code>*</code>...</li>
<li>...<code>/</code>...</li>
<li>...<code>%</code>...</li>
</ul>
</li>
<li>6 <strong>Left Associative</strong> Lower Arithmetics
<ul>
<li>...<code>+</code>...</li>
<li>...<code>-</code>...</li>
</ul>
</li>
<li>5 <strong>Left Associative</strong> Bit Shift
<ul>
<li>...<code>&lt;&lt;&lt;</code>...</li>
<li>...<code>&gt;&gt;&gt;</code>...</li>
</ul>
</li>
<li>4 Order Comparison
<ul>
<li>...<code>&lt;</code>...</li>
<li>...<code>&gt;</code>...</li>
<li>...<code>&lt;=</code>...</li>
<li>...<code>&gt;=</code>...</li>
</ul>
</li>
<li>3 Equality Comparison
<ul>
<li>...<code>==</code>...</li>
<li>...<code>!=</code>...</li>
</ul>
</li>
<li>2 <strong>Left Associative</strong> LogicalAnd ...<code>&amp;&amp;</code>...</li>
<li>1 <strong>Left Associative</strong> LogicalOr ...<code>||</code>...</li>
<li>0 <strong>Left Associative</strong> <a href="#">Index &amp; its variants</a></li>
</ul>
<hr>
<h3 id="block" tabindex="-1">Block</h3>
<p>Block is a very special syntax in <strong>Cyraon</strong>.</p>
<pre class="hljs"><code>{
    // empty
    ;

    // evaluate an expression
    1 + 2;

    // a statement
    let x = 2;

    // export a value
    a =&gt; 7,

    // exported value can be used later
    a =&gt; a * 6,

    // export-symbol can be generated
    [ &quot;user_$(rng())&quot; ] =&gt; User .new(),
    // is identical to (assume rng returns 1)
    // user_1 =&gt; User .new()
}
</code></pre>
<p>Block is an expression</p>
<pre class="hljs"><code>let my_block = {
    // would not execute immediately
    Console.print &quot;Block is lazy&quot;;
    a =&gt; 23,
    x =&gt; fx a,
};
</code></pre>
<!-- TODO: use another name instead of `destruct$` macro -->
<p>Destructing a block's exports, would also execute the block if haven't yet</p>
<pre class="hljs"><code>destruct$ my_block {
    a, x
};
// Block is lazy

// alias
destruct$ my_block {
    a =&gt; b, x =&gt; y
};
// second time destruct$ doen't output &quot;Block is lazy&quot;
</code></pre>
<p><code>destruct$</code> is an example of macro in <strong>Cyraon</strong>. Another example of macro that's closely tied with the Block is <code>map$</code>.</p>
<pre class="hljs"><code>let my_map = map$ {
    // map b to true
    b =&gt; true,

    // yet you can do something and doesn't map the result to anything
    rng.set_seed 0;
    a =&gt; rng(),

    // yet you can have local variables declared and used later
    let x = 5;
    y =&gt; x ** 2,
};

// my_map stores relationships of mapping
my_map[&quot;b&quot;] // true
my_map[&quot;a&quot;] = 2; // values can be changed later
</code></pre>
<!-- TODO: add link to std::map -->
<p>more to see <a href="">std::map</a></p>
<h3 id="lambda" tabindex="-1">Lambda</h3>
<pre class="hljs"><code>// (ar0, arg1, ...) -&gt; &lt;expr&gt;
let add = (a, b) -&gt; a + b;

// Single arg and we can ignore the parenthesis
let add_1 = x -&gt; x + 1

// This is extremely useful in currying
let curried_add = a -&gt; b -&gt; a + b;

// and curried_add could be called as
let three = curried_add 1 2;
</code></pre>
<h3 id="function-call" tabindex="-1">Function Call</h3>
<pre class="hljs"><code>// usually, functions are just what you would normally expected
f(a, b, c);
however
</code></pre>
<h3 id="variable-assignment" tabindex="-1">Variable Assignment</h3>
<pre class="hljs"><code>let <span class="hljs-tag">&lt;<span class="hljs-name">variable-name</span>&gt;</span> = <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span>;
</code></pre>
<pre class="hljs"><code><span class="hljs-attribute">AssignStmt</span> = KW_LET Ident SYN_EQ expr SYN_SEMICOLON
</code></pre>

</body>
</html>
	